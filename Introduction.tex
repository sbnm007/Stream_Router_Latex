% \chapter{Introduction}
% Web Applications now widely normalized and commonly built by almost anyone is built with a sequence of high-level abstractions in today's time. The networking aspect as a fact is completely abstracted. The lower level language implementation of softwares and its stability (networking protocols, operating systems, databases, etc) are the reason we are able to successfully build and deploy highly available modern architectures. In this mordern architectures several design practices and principles are followed such as Reliability, Availability, Scalability, Security, Interoperability, Reseliance, etc. In order to acieve these principles several tools have been developed and one such tool is Kubernetes which is the backbone of almost all the modern running complex applications. Another such concept is Networking Protcols which are the fundamental design with which all modern systems interact and communicate. . The IETF (Internet Engineering Task Force) is responsible for standardizing a particular design . This dissertation aims to explore one such implementation of networking protocol which has not yet been widely adopted by all the modern systems yet. In this dissertaion we will explore these aspects and its implementation challenges and different methods and strategies followed to demonstrate the advantage of the working solution.


% \section{Motivation}

% Give intro
% Mention Kubernetes wide adoption
% Personally saw its wide adoption in industry during my time as a Devops Engineer
% Working knowledge with playing around with Http1.2 and http2 hence curiosity for newer Generation Protocol http3.
% Modern applications widely use tcp/ip, websockets, webrtc for realtime communication even with newever protcols with play there are only few companies who are experimenting with it. It gives as an area of high research pontential. In Kubernetes espcecially its all based in tcp/ip, Http1.1 and http2. Support for newer implementaion is not widely supported which brings us something to work with. 





% \section{Research Question}

% As part of the Introduction chapter, it would be good to discuss an abstract formulation of your research question. This discussion takes place before the reader has viewed the detailed description of the area in the state of the art chapter; so, this discussion of the research question needs to be high-level and abstract in order to avoid relying on detail knowledge of the research area.

% A research question should not ask if something can be achieved or not i.e. "Can a GUI be constructed that visualises a simulation of atoms?" The answer to these questions is always "Yes, with sufficient time and resources almost everything can be achieved."\footnote{I exclude "building a time machine" here.} 

% "How does approach X affect issue Y?" or "Is approach A a suitable approach to issue B and improve on existing approaches?" or "Does approach H provide better performance in comparison to approach I when applied to problem K?" In the evaluation you then, it would be good to answer this question. Examiners may also raise questions along the line: "What does your work contribute to the area?", "Was your approach to address a given issue a suitable approach?", "How does your approach compare to existing approaches - which you reviewed as part of your state-of-the-art research?".

% Part of the motivation to cover the research question here is that the current forms for the evaluation of dissertations contains a section that explcilitly asks examiners to assess the clarity of the definition of the research question. In order to make this easier for the examiner to complete this assessment, provide a clear definition of the research question here. The actual problem definition that is being addressed in the dissertation can be covered in detail after the discussion of the state of the art.

% \section{Structure \& Contents}

% At the end of the introduction, a layout of the structure and the contents of the following chapters should be provided for the reader. The overall goal of all descriptions of contents that follows these descriptions is to prepare the reader. The reader should not be surprised by any content that is being presented and should always know how content that is currently being read fits within an overall dissertation.

% As part of your research before starting the write-up of your dissertation, you should have been exposed to 4 or more dissertations from your institution that represent good examples of dissertation documents - if this has not happened, you should talk to your supervisor  about this. These documents should act as examples which complement the guidance provided by your supervisor and the text in this document.

% Currently, this latex template is structured in a very traditional way i.e. the chapters and sections suggested in this template may make sense for the description of the majority of projects in Computer Science. However, you have to decide for yourself if this structure is suitable for your document or if it needs to be adjusted. Ideally, when you begin your write-up, start by creating a skeleton table of contents of your document by creating sections and subsections as an initial structure of your draft, in order to developing a mental image of the layout of your dissertation.




\chapter{Introduction}
\label{chap\:Introduction}

The world of web communication has changed tremendously over the last couple of decades particularly because of growing demand for instance access to information. This results in need for ultra low-latency, high-throughput and resilient data-exchange mechanisms. The history of internet started with web traffic being based on HTTP/0.9, HTTP/1.0, each successive version, including HTTP/1.1 and HTTP/2, has managed to increase efficacy in the form of persistent connections and multiplexing \cite{kurose2017}. These enhancements have however been limited by their dependence on the Transmission Control Protocol (TCP), a transport layer protocol specifically designed for exchanging reliable information. TCP Head-of-Line (HOL) blocking has been one of the most persistent challenges that occurs in this scenario, as loss of packets in one stream blocks packets in other streams until TCP has successfully retransmitted the lost packet.

To overcome such inherent limitations, the research community and IETF (Internet Engineering Task Force) have introduced QUIC (Quick UDP Internet Connections) \cite{rfc9000}, a modern transport layer protocol that is built on top of User Datagram Protocol (UDP). QUIC, and by extension HTTP/3 \cite{rfc9114}, its application-layer protocol, introduces several features such as stream-level multiplexing, reduced handshake latency via 0-RTT connections, connection migration, and integrated encryption leveraging TLS 1.3 protocol. These features significantly increase performance particularly in environments which require critical real-time responsiveness such as video conferencing, online gaming, financial trading platforms, and interactive media.

Another protocol building on QUIC like HTTP/3 is WebTransport \cite{webtransport-draft}. WebTransport is a web API designed to support unidirectional and bidirectional, multiplexed communication between web clients and servers, allowing developers to build applications that require granular, low-latency communication without resorting to workarounds like WebSockets, Polling, multipath TCP (MTCP), etc. By exposing the different capabilities of HTTP/3 and QUIC through a secure and efficient JavaScript interface, WebTransport stands as a fundamental building block towards a next generation protocol suitable for real-time web applications.

However, even with these developments in the protocol, WebTransport adoption in the real world of the modern web and commonly deployed cloud-native, especially in Kubernetes \cite{kubernetes-docs}, remains a significant challenge. Kubernetes has emerged as the dominant container orchestration platform because of its robust support for scalability, self-healing, and infrastructure management using declarative syntax. Yet, within Kubernetes the networking abstractions and ingress controllers which allow the traffic into the environment are primarily designed for HTTP over TCP and UDP, offering limited to no support for the semantics of HTTP/3 or QUIC beyond generic UDP passthrough.

Current networking solutions for kubernetes such as ingress controllers (e.g., NGINX \cite{nginx-ingress-docs}, Traefik) and load balancers lack visibility into the multiplexed nature of QUIC streams. As a result, all streams within a QUIC connection are routed uniformly to a single backend service, regardless of their function or content type. This places limits on the potential benefits of WebTransport in microservice architectures, where different stream typesâ€”such as audio, video and chat could be directly proxied and sent to microservices that are optimized for their respective workloads.




\section{Motivation}

The shift to real-time web communication is currently the next big thing. The rise of streaming platforms such as Twitch, YouTube, and Kick demonstrates the growing demand for delivering real-time streams of data to millions of users across the world \cite{kreps2011}. With this surge in real-time big data, it is interesting to explore the potential advancements that could be achieved through lower-latency and more efficient performance outcomes enabled by the adoption of the WebTransport protocol.

During my time as a DevOps Engineer, I personally observed the heavy dependency on the TCP networking protocol when working with Kubernetes-based solutions. My initial motivation stemmed from asking myself a few key questions about this dependency.

The core motivation discussed in this dissertation is the absence of native, stream-conscious routing support for WebTransport traffic in the Kubernetes environment. Although QUIC and HTTP/3 address many protocol-level performance issues associated with TCP, they do not yet scale effectively for microservice ecosystems. This is due to the current inability of Kubernetesâ€™ networking and ingress infrastructure to support granular stream-level routing and application-aware processing.

Specifically, the limitations of existing Kubernetes networking and ingress infrastructure are outlined in the following ways, which serve as the primary motivation for this dissertation

\begin{itemize}
\item \textbf{Lack of Stream-Level Visibility:} QUIC streams within a single connection are opaque to existing Layer 4 load balancers. Without visibility into individual streams, ingress controllers cannot differentiate between types of data or implement tailored routing logic.

\item \textbf{Monolithic Connection Handling:} The entire QUIC connection is treated as a single UDP session and directed to one backend, regardless of the number or nature of streams it carries. This eliminates the possibility of decomposing responsibilities across multiple microservices, leading to tightly coupled designs and inefficient resource utilization.

\item \textbf{Absence of Application-Layer Intelligence:} Ingress controllers lack insight into the semantics of WebTransport streams, making it impossible to apply policies such as stream-based quality of service (QoS), content-based routing, or differentiated handling of critical and non-critical data flows.

\item \textbf{Limited Protocol Translation Capabilities:} Many backend services still rely on HTTP/1.1 for communication. The absence of mechanisms to terminate HTTP/3 and translate individual streams into HTTP/1.1 requests further hinders interoperability and adoption in legacy-compatible environments.


\end{itemize}

This set of challenges are a major motivation to attempt productionizing WebTransport, especially when working with streams and microservices within Kubernetes-powered architecture, where one of the key architectural advantage is modularity, observability, and dynamic routing.

\section{Research Objectives}

The overarching aim of this dissertation is to bridge the aforementioned gap by introducing a WebTransport-aware routing system that seamlessly integrates into Kubernetes environments. The system enables application-layer routing decisions based on individual stream semantics, transforming the way real-time data is managed in cloud-native platforms.

\subsection{Primary Objective}

This dissertation aims to fill the gap described above with the development of a WebTransport stream-aware routing system that will integrate easily within the Kubernetes environment. Application-layer routing decisions are facilitated using individual stream semantics that strives to change the management of real-time information within cloud-native platforms.

\subsection{Secondary Objectives}

\begin{enumerate}
\item \textbf{Protocol Translation:} Support translation of HTTP/3/WebTransport to HTTP/1.1 and achieve the compatibility of the technology with current microservice backends that have still not implemented newer protocol types.

\item \textbf{Stream Demultiplexing:} Establish effective systems to understand QUIC streams on the basis of a fixed packet structure, thus logically isolating the various data data like audio, video and control messages.

\item \textbf{Dynamic Configuration:} Develop a flexible, configuration-driven routing mechanism that supports hot-reloading and dynamic updates via Kubernetes-native objects such as ConfigMaps and Secrets.

\item \textbf{Real-time Processing Use Case:} Demonstrate to the practical feasibility by building a scenario with live streaming of different data such as audio, video, and chat, to process and integrate with streaming backend systems like Apache Pulsar.

\item \textbf{Performance Evaluation:} To evaluate the system wiht metrics such as backend performance buffer utilization, cpu and memory.

\end{enumerate}

\section{Methodology and Approach}

This research follows a task decomposition approach by breaking down the large problem into manageable components and addressing each one iteratively and progressing towards a complete solution. The approach starts with dividing overall challenge of WebTransport stream routing into distinct phases that brings us closer to the goal. At a highlevel the divided tasks include configuring Kubernetes to accept incoming UDP traffic using tools, extracting individual WebTransport streams based on custom application-layer defined headers. Deploying each component in a configuration-driven mechanisms to classify and map stream types to corresponding backend services deployed within the Kubernetes cluster. Demultiplexing streams  and forwarding to its respective microservice. Finally establishing proper monitoring mechanisms for evaluation.

\section{Contributions}

This dissertation makes notable contributions to the field of cloud-native networking by building a WebTransport-aware proxy system for Kubernetes. The system built aims to route individual WebTransport streams using a custom QUIC demultiplexer which contributes to open-source development by providing a Proof of Concept, building upon the aioquic library \cite{aioquic-repo}. The solution supports dynamic routing through configuration files like ConfigMaps and Secrets, which can be updated without restarting the service providing easy deployable solution in kubernetes.


\section{Structure \& Contents}

The structure of this dissertation will contain seven chapters, progressing from theoretical considerations to execution, review and conclusions. The chapters are independent of each other and are organized based on logical flow.

\textbf{Chapter 1: Introduction} outlines the motivation, research goals, and scope of WebTransport routing in Kubernetes.

\textbf{Chapter 2: State of the Art} reviews relevant literature on QUIC, HTTP/3, Kubernetes networking, and identifies existing gaps.

\textbf{Chapter 3: Problem Formulation} defines the core challenges, research questions, and introduces the proposed WebTransport proxy.

\textbf{Chapter 4: Design} presents the high-level architecture, stream structure, routing logic, and Kubernetes integration patterns.

\textbf{Chapter 5: Implementation} details the development setup, proxy and microservice code, deployment with ConfigMaps and Secrets, and Apache Pulsar integration.

\textbf{Chapter 6: Evaluation} benchmarks system performance in terms of latency, throughput, and scalability under real-world scenarios.

\textbf{Chapter 7: Conclusions \& Future Work} summarizes findings, reflects on limitations, and suggests future improvements such as HTTP/3 pass-through and distributed scaling.
